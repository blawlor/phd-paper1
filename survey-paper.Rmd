---
title: "Engineering a Solution: A Review of Software Engineering Values in Bioinformatics"
author: "Brendan Lawlor, Paul Walsh"
date: "Cork Institute of Technology, Cork, Ireland"
output: 
  pdf_document:
    number_sections: true
bibliography: bibliography.bib
csl: brendan-custom.csl
abstract: There is a lack of software engineering skills in bioinformatic contexts. We discuss the consequences of this lack, examine existing explanations and remedies to the problem, point out their shortcomings, and propose alternatives. Previous analyses of the problem have tended to treat
  the use of software in scientific contexts as categorically different from the general
  application of software engineering in commercial settings. In contrast, we describe bioinformatic software engineering as a specialization of general software engineering, and examine how it should be practiced. Specifically, we highlight the difference between programming and software engineering, list elements of the latter and present the results of a survey of bioinformatic practitioners which quantifies the extent to which those
  elements are employed in bioinformatics. We propose that the best way to bring engineering values into research projects is to bring engineers themselves. We identify the role of Bioinformatic Engineer and describe how such a role would work within a bioinformatic research teams. We conclude by recommending an educational emphasis on cross-training software engineers into life sciences, and propose research on Domain Specific Languages to facilitate collaboration between engineers and bioinformaticians.
---

# Problem Description
This paper identifies a significant lack of software engineering practices in bioinformatics when compared to commercial software development, which prevents it from benefiting from decades of engineering efficiencies, rigour and quality. The problem is present in computational science in general, but for the purposes of this discussion, we will concentrate on bioinformatics. Software engineering skills are lacking, as is evident in the way in which software is developed in bioinformatic contexts. Although biologists and especially bioinformaticians possess programming skills, and use those skills as part of their day to day work, they do so in a way that is ad hoc, unstructured and not in line with modern standards of software engineering[@verma2013lack; @baxter2006scientific]. The problem has serious consequences for the field of bioinformatics and demands that we find effective solutions.

We will examine these consequences under a number of headings, but in all cases they boil down to two overarching effects: the bioinformatic community arrives at findings more slowly than it otherwise might, and those findings, when arrived at, are less reliable than they might otherwise be. By focusing on solutions to the lack of software engineering skills in bioinformatics, we can address both of these effects. A first step is to better understand their nature by identifying more precisely how and where they arise.

*Inability to Reproduce Findings*: A lack of software engineering infrastructure and techniques means that many publications which process data informatically cannot make that software or data available in a reproducible way for peer review. As a consequence, a significant percentage of findings is likely to be reversed or withdrawn from publication. The use of infrastructure such as source code control systems and command-line build tools would improve the situation, by giving researchers the ability to easily publish and share the software that was used as part of their work. But these tools are either unknown or simply considered unnecessary for small teams by bioinformatic researchers. 


*Unreliability of Findings*: All surveys on scientific software development we have reviewed cite a lack of software testing as being a constant theme of scientific development. Segal[@segal2007some] points out that the "lack of any disciplined testing procedure" is a characteristic of any development practice where the end user is also the developer. According to a review Morris [@morris2008some] "unit tests often do not exist". Because of the fundamentally important role of such tests in separating problems in the code from problems in the hypotheses, findings based on insufficiently tested software must be considered in turn insufficiently tested themselves. Compare this to the use of defective or uncalibrated lab equipment in order to fully appreciate the nature of the problem.


*Limitations in Data Sample Size*: Many scientists run their software on desktops despite the availability of clusters and this is most likely due to a lack of familiarity with software designs for parallel execution of tasks, or with alternative algorithmic approaches which would give better performance. The constraints that this practice inevitably imposes on sample size or sophistication of data analysis are clear. In order to execute programs to completion on desktops, even if in a time frame of hours and days[@prabhu2011survey], researchers will naturally reduce the number of sample points used, or eliminate steps which might increase statistical power but which have exponential or factorial performance profiles. A parameter study, for example, can benefit from pairwise comparisons of its features; but the number of such pairs is ${n \choose 2}$, where n is the number of features, so even modest values of n require concurrent programming and resource management to run to completion on desktop computers. 


*Slowing the Discovery Cycle*: Bioinformatic research is an iterative process in which the computational element takes up a significant percentage. If the researcher has to wait days to see computational results which will decide the next direction that the research is to take, momentum is lost and the entire process of research itself is slowed down. Software engineers can bring skills like performance optimisation and  concurrent programming to bear on this problem, significantly reducing waiting times.

*Reinventing the wheel*: According to Prabhu et al. [@prabhu2011survey] "a considerable portion of [scientists'] time is spent in many tedious [software development] activities" such as converting data formats or retro-fitting inherited software to work for new conditions. This is a direct consequence of insufficient software engineering infrastructure and practices around the research team. Researchers are obliged to repeatedly cobble together solutions for every new direction they take. Naturally the nature of these improvised solutions does not facilitate their reuse - they typically don't exhibit high levels of maintainability or build-reproducibility - and so the problem perpetuates itself.


In all of the above cases, we can discern a parallel to the argument made by Ioannidis[@ioannidis2005most] with respect to inexpert use of statistics in studies. The danger to progress in bioinformatics is that much research may later be found to be invalid due to inexpert or non-transparent development of software. As Verma et al. point out, "the end goal of creating accurate and reliable scientific software is no less critical [than with commercial software] since incorrect results would greatly compromise the validity of the discovery"[@verma2013lack]. This is an unsettling prospect indeed.

# Solutions from the Literature
These are some of the things that can go wrong in bioinformatic research when we fail to address the problem of its software engineering deficit. But why does this deficit arise in the first place? And what can be done to improve matters?  

A number of the authors we have reviewed offer explanations and remedies for the problems described above. Hannay et al. [@hannay2009scientists] identify a general lack of formal education and training and a reliance instead on informal learning from peers. Segal & Morris [@segal2008developing] among others emphasize the differences between scientific and commercial software development. Similarly, Verma et al. [@verma2013lack] cite a lack of requirements engineering in bioinformatic projects, as well as other factors that create the "unique situation for the field of software engineering" represented by bioinformatics. Umarji et al. [@umarji2009software] focus exclusively on the gaps in the education of bioinformatic software developers in software engineering principles.

It's important to correctly identify all of the significant causes of the problem. If we start with a false or incomplete diagnosis the treatment is unlikely to be effective. We will look in detail at the root causes proposed by previous studies, but from the previous paragraph we can see that there are some elements in common in the way previous authors have understood the problem, and so in the solutions that they have proposed. Here we will categorize them as Education, Methodology and Special Pleading, and they can be described as follows:

##Education
Bioinformaticians lack the training in Software Engineering tools and techniques. <to be completed>

##Methodology
The wrong processes - or no processes at all - are being applied to the practice of bioinformatic research.
[@verma2013lack] <to be completed>

##Special Pleading
According to this way of thinking, the field of scientific software development is so far removed from the commercial settings in which modern Software Engineering has emerged, that the rules from the latter simply do not apply. Authors have suggested that the two contexts are "fundamentally different" for reasons of subject domain complexity, requirements volatility and budgetary constraints. These differences make it problematic to "impose software engineering techniques on scientists"[@segal2008developing]. So much space has been given to the differences between scientific and commercial development, that it is useful to break it down further as follows.

###Subject Domain Complexity
Segal & Morris assert that in the case of scientific software development the subject matter is simply too complex for the "average developer". In a similar vein, Hannay suggests that "developers are much less likely to need to be domain experts" in "regular" software development compared to scientific. 

###Requirements Volatility
According to Segal & Morris, "full up-front requirement specifications are impossible" where scientists are concerned, and that requirements rather "emerge" on an ongoing basis. The suggestion is that this is a distinctive feature of scientific programming, which makes the application of software engineering techniques more difficult.

###Budget and Resources
Verma et al. cite tighter budget and timetable constraints as a differentiating factor of bioinformatic software development, and therefore as one possible cause of a lack of software engineering best practices in that field. 

###End User (Scientist) as Developer
A number of authors point out cultural differences between scientists and software engineers as an important issue. Segal & Morris suggest that due to the subject domain complexity already mentioned, developers are likely to be the end-user scientists. But as Verma et al. point out, biologist stakeholders - who are the primary stakeholders in these settings - "may be more inclined to sacrifice program structure to get something that works".

Naturally enough, the solutions proposed by these studies flow from the diagnoses of the problem. Those who conclude that the problem lies in education propose improvements to curricula. Those that implicate incorrect methodologies suggest alternatives that are more suitable to bioinformatics. Papers which emphasize the disconnect (real or perceived) between scientific and software engineering worlds don't offer suggestions about how to bring software engineering values into the scientific community, which again is natural, given their premise.

# Software Engineering vs Computer Programming

Before we examine the existing explanations and remedies for the software engineering deficit in bioinformatics, we make a brief but important digression: We outline the differences between computer programming and software engineering in order to prepare for later arguments that lean on these differences.

The skills required to program are not the same as the those required to engineer a software solution. Programming is a subset of the discipline of software engineering in much the same way that draftsmanship is a subset of the skills required for architecture. This uncontroversial fact is under-appreciated in scientific settings, for reasons about which we might only speculate. It takes a great deal longer to make a software engineer than it does simply to make a programmer. This should come as no surprise, given the fact that Software Engineering is a distinct academic course of studies and a distinct professional discipline. Practicing software engineers draw from a large body of academic knowledge and a long and vital component of workplace experience. There is a long-standing recognition, going back to venerable thought leaders like EW Dijkstra [@dijkstra1982selected], that software engineering is as much a craft as a science. As such, its skills are acquired as much through a kind of apprenticeship as through the academic studies that precede it. This has been appreciated enough by educators that some have sought to incorporate elements of that apprenticeship into academic coursework [@surendran2002simulating]. The elements of software engineering practice that are often absent from bioinformatic teams correspond to those elements which are typically learned by the software engineering apprentice (source control, build systems, unit testing etc). This is hardly surprising: Scientists learn more software development skills informally from other scientists, and through self-study, than through formal education[@hannay2009scientists]. In one study 84% of scientists who were surveyed indicated that they had relied mostly on self-learning for their software skills[@verma2013lack]. In either case, neither mode of learning can be compared to the prolonged exposure to best practices that software engineers typically enjoy.

## Elements of Software Engineering Practice
In this section, we give an overview of some of the primary tools, techniques and skills of software engineering, and present the results of a survey which seeks to quantify the prevalence of these software engineering elements in bioinformatic settings. Our choice of which tools and techniques to emphasize are based on experience as practitioners, and we find ourselves in full agreement with other authors such as Wilson et al. [@wilson2014best] with respect to those choices.

The following diagram shows the essential elements of software engineering practice, and illustrates the dependencies between them. We categorize Software Engineering elements into the separate layers of Infrastructure, Processes and Practices, each layer building on the one below. 

```{r fig.width=7.5, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ProcessPyramid.png", TRUE)
 grid.raster(img)
```

The basis of good practice lies in the correct choice of the *Tools and Infrastructure* indicated in the above figure. Of course a software engineer chooses the tools based on the practices that she wishes to encourage, but their presence in a development environment is like a genetic marker that accompanies good engineering standards. The layers representing automated *Processes* and experience-based *Practices* contain their own 'markers' which depend on those in the layers below: Even the most skilled and experienced engineer will be thwarted by an inadequate development environment. With this in mind, we designed a survey to measure the prevalence of these layered 'markers' in bioinformatic research teams. 

## A Survey of Bioinformatic Software Engineering Practice
Describe the survey and its results...


# Alternative Solutions
The results of our survey confirm the deficit in bioinformatic software engineering skills, and we now look at what its causes and remedies might be, beyond what has already been discussed in the reviewed literature. We believe that in order to address this deficit effectively, we must take into account the difference between computer programming and software engineering as discussed above. We assert that it is impractical, if not impossible, to introduce the missing software engineering expertise into bioinformatics by treating that expertise as a sub-component of bioinformatics. Software Engineering encompasses too large a body of knowledge, which is acquired by too different a form of education to simply be bolted on to existing bioinformatic curricula. Put another way, we believe that the most effective way of introducing software engineering values into bioinformatic research is to introduce software engineers themselves, by recognizing the separate role of the Bioinformatic Engineer in bioinformatic research projects, and identifying the interface between the engineer and the scientist. Before we discuss how this might be done, we look again at the alternatives and the arguments against introducing software engineering values in the first place.

While improvements in bioinformatic curricula, as suggested by Umarji et al. [@umarji2009software] would be a positive step that could lead to improved communication between bioinformaticians and software engineers, such improvements would not be not sufficient to bridge the current gap. We believe that in addition, educators should target software engineering curricula and create specialized Masters and PhD programs in Bioinformatic Engineering, creating specialized software engineers who can dialog with biologists and bioinformaticians *as customers* based on a shared understanding of the research environment and the biology domain. 

Selecting appropriate methodologies is another necessary but insufficient step. Investigations into software engineering methodologies suit bioinformatics projects are worthy, but who would steer the use of such techniques in the absence of a skilled and experienced software engineer? 

## Special Pleading
What about those arguments touched on above which suggest that scientific software development is too complex, too fluid in its requirements, and too badly funded to use software engineering techniques? Such arguments are based on special pleading and are problematic in a number of ways. Firstly, they don't point towards solutions. And secondly, such claims of being a special case can be arrived at too easily by specialist groups such as biologists, and fit too well with assumptions and professional biases - asserted and accepted without every being truly examined. We examine those assumptions now in the order outlined above: Complexity of Domain, Volatility of Requirements and Limited Resources.

### Complexity
Two obvious features of complexity are intricacy and unpredictability. Biological processes are undoubtedly *intricate* - they contain many levels and numerous inter-dependent components which in turn lead to intricate domain models in bioinformatic software. Intricacy can be tamed by a 'divide and conquer' approach: identifying and separating the various components of a complex system. In fact, the role of any skilled software engineer is to map this problem domain to a solution domain (a software implementation). Thus tamed, a biological problem domain is no more unpredictable than a business one. Most of the subsequent complexity of any project is down to the unpredictable nature of the people and processes working on it, a factor which increases with project size rather than subject nature. 

### Volatility

The observation that scientific requirements are simply too fluid will bring a rum smile to the face of any experienced software engineer. The day-to-day reality of commercial projects is very different to the clean lines described in methodology literature. Perceived business needs always come first, often to the detriment of best practice. Part of the engineer's job is to incorporate unexpected and even capricious requirements into the project while minimizing the damage done. 

In one sense, the life sciences enjoy an important advantage over business: The problem domain is much more stable over time and across projects. Certainly it grows to incorporate discoveries and occasional upheavals. But amino acids and cell division don't go in and out of fashion like financial instruments or business processes. Biologists uncover and even invent, but the underlying biology itself limits novelty. This allows engineers to build up *and usefully retain* expertise in the problem domain. (This can not be said about commercial domains, where the only underlying biology that limits change is the neo-cortex of the customer.) 

One feature of modern software development which can take advantage of this relatively stable domain and facilitate communication between engineer and scientist is the Domain Specific Language (DSL)[@van2000domain]. As an alternative to a general purpose programming language, a DSL can provide a fluent interface between the problem domain of the biologist and the solution domain of the engineer. As such a DSL "offers substantial gains in productivity and even enables end-user programming"[@kosar2008preliminary]. As pointed out by Swertz et al, "[t]he working systems biologist wants to apply software tools to increase the understanding of biological function without having to 'tinker under the hood'"[@swertz2007beyond]. We consider the application of DSLs to bioinformatic software development as an exciting and worthy subject of further research.

### Resourcing
Budgets on commercial software projects are tight, as are the deadlines, and any experienced developer knows that there is a continuous cost/benefit calculation involved when making any significant technical decision. In this sense, commercial projects are no different to scientific research programs. What does differ is the budgeting process. Bioinformatic researchers need to allocate adequate resources for software development at the outset, but as one author has pointed out, scientists tend to underestimate the cost of software [].


## Bioinformatics Engineering
We are arguing here for the recognition of the separate role of Bioinformatic Engineer in research teams, but this raises many questions of a practical nature and perhaps some philosophical ones too. How should bioinformatic engineers and bioinformaticians best communicate? Where would their competencies overlap? What should small teams with limited funding do? And in any case, does this separation of roles fly in the face of the cross-disciplinary nature of bioinformatics itself?
 
```{r fig.width=6, fig.height=4.5, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/BioinformaticProjectRoles.png", TRUE)
 grid.raster(img)
```

The intersection of the two sets in the above diagram show the role that education can play in preparing bioinformaticians and bioinformatic engineers to work together. Engineers need to know enough about the biology domain to communicate effectively with bioinformaticians. Complexity of the problem domain does not prevent this from happening in similarly complex commercial settings, and despite much special pleading in the literature there is insufficient reason to think that bioinformatics would be different. Commercial software engineers typically specialize in 'verticals' and market themselves as much on the basis of their domain experience as on their technical skills. Bioinformatics can be seen as a particularly stable and well defined problem domain, itself subdivided into various verticals. Bioinformaticians already understand programming enough to communicate their ideas and requirements through code (even if, as we have indicated earlier, there is enormous potential for DSLs to close the communication gap even further).

The non-intersecting parts of the two sets demonstrate the need for the bioinformatic engineer in the first place. The entire field of software engineering is too large to incorporate into the skillset of bioinformatics, and much of it is of no interest to the bioinformatician in the first place. Nobody expects him to build, or even understand the inner workings of, the centrifuges and mass spectrometers that are so essential to research. Why then should we expect him to master the art of building large-scale, performant and production-ready software systems? 

The point we are making in distinguishing the role of Bioinformatics Engineer can be summarized as follows: Software Engineering is vital to the discipline of bioinformatics *without being a core skill of that discipline*. This question of specialization is a logistic or even economical one which finds echoes in Ricardo's Law of Comparative Advantage[]: Even if it were possible for bioinformaticians to subsume the entire discipline of software engineering into their body of knowledge, it would not be desireable. It would simply represent bad value. A bioinformatician investing the necessary time in engineering skills would pay a heavy price in terms of Opportunity Cost - the time *not* spent on study and research in core biological questions. Much better to lean on an engineering specialist in those key moments of research and development when engineering skills come to the fore.

What, then, are those key moments? The following diagram categorizes the kinds of software development that would typically take place in a research team into four quadrants, based on two variables: Whether the work is core or peripheral to the team's output, and whether the resulting software should be considered temporary or permanent. We can use these categories to pinpoint the phases of research where bioinformaticians could increase their productivity by handing over to bioinformatic engineers, or at the very least, "change hat" and temporarily adopt an engineering approach.

```{r fig.width=7, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ScientificSoftwareUseScenarios.png", TRUE)
 grid.raster(img)
```

To explain what we mean by these categories and variables, we refer to Morris' observation [@morris2008some] that "[o]ne concern is that scientific prototype code, if successful, segues into applications that are distributed for wider research use. Later it may be adopted for production purposes, sometimes even for
safety critical use." In other words, it is important to allow bioinformaticians to create code that is exploratory in nature but fragile from an engineering point of view. But it is equally important to ensure that such code does not form the basis of published findings or shared products and tools. We model this feature with the variable that distinguishes between temporary and permanent software. 

Once we know which category a particular piece of software belongs to, we can create procedures for moving it to a different category should the need arise. For example, according to Sanders and Kelly [@sanders2008dealing] some teams took a "do it twice" approach - that is, a rewrite of software according to more exacting engineering requirements. This corresponds to moving software from the upper half to the lower half of the the above diagram. So this is already practiced in some research teams. The point is to explicitly recognize these categories and put processes in place to avoid the kind of error that Morris describes.

The other variable, Core/Peripheral, distinguishes between software that is used as part of the scientific discovery process in a specific line of research, and code that could be considered 'utility code' to be reused in many different settings. The former should in principle be published along with the findings it helped to produce. The latter might find it's way into a commercial or opensource product to be shared with the wider bioinformatic community. In both cases, the need for a transformation from temporary to permanent is the same, but the engineering skills and processes used to achieve it would differ - hence the distinction between them.

If a research team cannot fund a dedicated software engineer, it can still make use of the ideas presented here. The cross-over points in competencies that we have identified above can serve as process boundaries, indicating where bioinformaticians should "change hat" and begin to approach their work with different goals in mind. But in order for this to happen, they must know that these boundaries exist; at a minimum they should be educated in an *appreciation* of software engineering even if their own engineering training will be - of necessity - a peripheral part of their curriculum. As teams ramp-up in size and funding, they will permit themselves to take on specialists, and we content that bioinformatic engineers should be one such category.

# Conclusion
Bioinformatics is still in the cradle, compared to many of its sibling sciences. In common with many other fields that combine computation, mathematics and statistics with the sciences, a lot of thought and energy is going into the creation of truly cross-disciplinary practitioners. The goal is to combine in one brain a rich knowledge of both biology and computation, because answering the questions in one has become heavily dependent on mastering the skills of the other. 

While there is no doubt about the soundness of this ambition, we feel that a distinction must be made between computational skills and software engineering skills. More to the point, we feel that these skill sets are so diverse and mastered by such different methods, that it is unrealistic to expect a single practitioner to combine biology, computational methods and software engineering. Moreover, it is unnecessary and uneconomical to try. 

The alternative is already available to us. Software engineering is a discipline in which we apply computational skills to problems of other disciplines in such a way as to result in robust, reliable and maintainable solutions. While some fields of application are more exacting than others there is *no qualitative difference* between commercial software engineering and scientific software engineering. The extra degree of scientific complexity has parallels in commercial software development. The existing tools, techniques and practices of software engineers can bend to the particular needs of research. The only question that remains is how to reliably place those skills of modern software engineering at the disposal of bioinformatic researchers.

We argue for the explicit recognition of the role of the bioinformatic engineer, a software engineer who has been educated in the standard way for that discipline, and has specialized in the 'vertical' of systems biology (or a sub-field such as genomics, or metabolomics). Such an individual would embody all the skills that one would expect from an expert software engineer but would also have a deep understanding of the kinds of problems that biologists need to solve, and the manner in which they go about their research. In other words, we believe that the most effective way of introducing software engineering values into bioinformatic research is to introduce software engineers themselves. As a reasonable compromise, where this ideal is not immediately achieveable, bioinformaticians could perform the *role* of bioinformatics engineer during the deliniated phases of project work that we have identified. 

One difficulty to be addressed as part of the proposed approach is hinted at by []. The way in which research projects are funded does not currently take into account the costs associated with developing software. While not every project will be able to budget for a full-time bioinformatic engineer, research groups should be able to share such resources, or make use of specialized external software companies which would grow in number to meet demand.

The bioinformatic engineer does not in any sense remove the need for the cross-disciplinary figure of the bioinformatician. On the contrary - it is essential to an effective collaboration between bioinformatician and engineer that one have the skills and vocabulary to communicate needs to the other. The bioinformatician will very often communicate with the engineer using source code. As suggested by Wilson et al. it would be best if the bioinformatician also had a working knowledge of the basic tools of software engineering such as source control and unit tests. But the responsibility of identifying problems in design and code, fixing them, and shaping exploratory code into well-engineered solutions would lie with the bioinformatic engineer. We predict that this would substitute hours of drudgery for the scientist with hours of true productivity, and at the same time ensure performant, testable, maintainable and shareable code for the bioinformatic field at large.

## Recommendations

* Explicit recognition of the role of Bioinformatic Engineer, along with a shared understanding of the competencies, functions and interfaces of that role.
* The creation of specialist post-graduate curricula to allow software engineering graduates to specialize in bioinformatic engineering.
* Research into bioinformatic Domain Specific Languages to facilitate collaboration between bioinformaticians and bioinformatic engineers.
* Adequate funding for software engineering as part of bioinformatic research projects.
* Measures to encourage the creation of bioinformatic engineering companies to service the needs of smaller research teams which cannot afford dedicated internal bioinformatic engineering staff.

# References