---
title: "A Review of Software Engineering Values in Bio-informatic Contexts"
author: "Brendan Lawlor, Paul Walsh"
date: "Saturday, October 27, 2014"
output: 
  pdf_document:
    number_sections: true
bibliography: bibliography.bib
csl: brendan-custom.csl
abstract: In this paper we consider the problem of a lack of software engineering
  skills in bio-informatic contexts and discuss the consequences of this lack. We
  examine existing explanations and remedies to the problem, point out their shortcomings,
  and propose alternatives. Previous analyses of the problem have tended to treat
  the use of software in scientific contexts as categorically different from the general
  application of software engineering in commercial settings. In contrast, we describe it as a specialization of that discipline, and examine 
  how it is practiced. Specifically, we highlight the difference between programming
  and software engineering, list elements of the latter and present the results of
  a survey of bio-informatic practitioners which quantifies the extent to which those
  elements are employed in bio-informatics. In the light of the results we identify
  the role of the bio-informatic engineer - which is unaccounted for in the literature
  - and propose an educational emphasis on cross-training experienced software engineers
---

  
There is a problem in the practice of bio-informatics. The problem is present in computational science in general, but for the purposes of this discussion, we will concentrate on bio-informatics. Software engineering skills are lacking, as is evident in the way in which software is developed in bio-informatic contexts. Although biologists and especially bio-informaticians possess programming skills, and use those skills as part of their day to day work, they do so in a way that is ad hoc, unstructured and not in line with modern standards of software engineering. The problem has serious consequences for the field of bio-informatics and demands that we find effective solutions.

[@verma2013lack; @baxter2006scientific]

We will examine these consequences under a number of headings, but in all cases they boil down to two overarching effects: the bio-informatic community arrives at finding more slowly than it otherwise might, and those findings, when arrived at, are in any case less reliable than they might otherwise be. By focussing on solutions to the lack of software engineering skills in bio-informatics, we can address both of these effects. A first step is to better understand their nature by identifying more precisely how and where they arise.

*Inability to Reproduce Findings*: A lack of software engineering infrastructure and techniques means that many publications which process data informatically cannot make that software or data available in a reproducible way for peer review. As a consequence, a significant percentage of findings is likely to be reversed or withdrawn from publication. The use of infrastructure such as source code control systems and command-line build tools would improve the situation, by giving researchers the ability to easily publish and share the software that was used as part of their work. But these tools are either unknown or simply considered unnecessary for small teams by bio-informatic researchers. 


*Unreliability of Findings*: All surveys on scientific software development we have reviewed cite a lack of software testing as being a constant theme of scientfic development. Segal[@segal2007some] points out that the "lack of any disciplined testing procedure" is a characteristic of any development practice where the end user is also the developer. According to a review Morris [@morris2008some] "unit tests often do not exist". Because of the fundamentally important role of such tests in separating problems in the code from problems in the hypotheses, findings based on insufficiently tested software must be considered in turn insufficently tested themselves. Compare this to the use of defective or uncalibrated lab equipment in order to fully appreciate the nature of the problem.


*Limitations in Data Sample Size*: Many scientists run their software on desktops despite the availability of clusters and this is most likely due to a lack of familiarity with software designs for parallel execution of tasks, or with alternative algorithmic approaches which would give better performance. The contraints that this practice inevitably imposes on sample size or sophistication of data analysis are clear. In order to execute programs to completion on desktops, even if in a timeframe of hours and days[@prabhu2011survey], reserachers will naturally reduce the number of sample points used, or eliminate steps which might be useful but which have exponential performance profiles.


*Slowing the Discovery Cycle*: Bio-informatic research is an iterative process in which the computational element takes up a significant percentage. If the researcher has to wait days to see computational results which will decide the next direction that the research is to take, momentum is lost and the entire process of research itself is slowed down. 

*Reinventing the wheel*: According to Prabhu et al. [@prabhu2011survey] "a considerable portion of [scientists'] time is spent in many tedious [software development] activities" such as converting data formats or retro-fitting inherited software to work for new conditions. This is a direct consequence of insufficient software engineering infrastucture and practices around the research team. Researchers are obliged to repeatedly cobble together solutions for every new direction they take. Naturally the nature of these improvised solutions does not facilitate their reuse - they typically don't exhibit high levels of maintainability or build-reproducibility - and so the problem perpetuates itself.


In all of the above cases, we can discern a parallel to the argument made by Ioannidis[@ioannidis2005most] with respect to inexpert use of statistics in studies. The danger to progress in bio-informatics is that much research may later be found to be invalid due to inexpert or non-transparent development of software. As Verma et al. point out, "the end goal of creating accurate and reliable scientific software is no less critical [than with commercial software] since incorrect results would greatly compromise the validity of the discovery"[@verma2013lack]. This is an unsettling prospect indeed.

These are some of the things that can go wrong in bio-informatic research when we fail to address the problem of its software engineering deficit. But why does this deficit arise in the first place? And what can be done to improve matters?  

A number of the authors we have reviewed offer explanations and remedies for the problems described above. Hannay et al. [@hannay2009scientists] identify a general lack of formal education and training and a reliance instead on informal learning from peers. Segal & Morris [@segal2008developing] amongst others emphasise the differences between scientific and commercial software development. Similarly, Verma et al. [@verma2013lack] cite a lack of requirements engineering in bio-informatic projects, as well as other factors that create the "unique situation for the field of software engineering" represented by bio-informatics. Umarji et al. [@umarji2009software] focus exclusively on the gaps in the education of bio-informatic software developers in software engineering principles.

It's important to correctly identify all of the significant causes of the problem. If we start with a false or incomplete diagnosis the treatment is unlikely to be effective. We will look in detail at the root causes proposed by previous studies, but from the previous paragraph we can see that there are some elements in common in the way previous authors have understood the problem, and so in the solutions that they have proposed. Here we will categorize them as Education, Methodology and Special Pleading, and they can be described as follows:

##Education
Bio-informaticians lack the training in Software Engineering tools and techniques. <to be completed>

##Methodology
The wrong processes - or no processes at all - are being applied to the practice of bio-informatic research.
[@verma2013lack] <to be completed>

##Special Pleading
According to this way of thinking, the field of scientific software development is so far removed from the commercial settings in which modern Softare Engineering has emerged, that the rules from the latter simply do not apply. Authors have suggested that the two contexts are "fundamentally different" for reasons of subject domain complexity, requirements volitility and budgetary constraints. These differences make it problematic to "impose software engineering techniques on scientists"[@segal2008developing]. So much space has been given to the differences between scientific and commercial development, that it is useful to break it down further as follows.

###Subject Domain Complexity
Segal & Morris assert that in the case of scientific software development the subject matter is simply too complex for the "average developer". In a similar vein, Hannay suggests that "developers are much less likely to need to be domain experts" in "regular" software development compared to scientific. 

###Requirements Volatility
According to Segal & Morris, "full up-front requirement specifications are impossible" where scientists are concerned, and that requirements rather "emerge" on an ongoing basis. The suggestion is that this is a distinctive feature of scientific programming, which makes the application of software engineering techniques more difficult.

###Budget and Resources
Verma et al. cite tighter budget and timetable contraints as a differenciating factor of bio-informatic software development, and therefore as one possible cause of a lack of software engineering best practices in that field. 

###End User (Scientist) as Developer
A number of authors point out cultural differences between scientists and software engineers as an important issue. Segal & Morris suggest that due to the subject domain complexity already mentioned, developers are likely to be the end-user scientists. But as Verma et al. point out, biologist stakeholders - who are the primary stakeholders in these settings - "may be more inclined to sacrifice program structure to get something that works".

Naturally enough, the solutions proposed by these studies flow from the diagnoses of the problem. Those who conclude that the problem lies in education propose improvements to curricula. Those that implicate incorrect methodologies suggest alternatives that are more suitable to bio-informatics. Papers which emphasise the disconnect (real or perceived) between scientific and software engineering worlds don't offer suggestions about how to bring software engineering values into the scientfic community, which again is natural, given their premise.

<Question: How to present Wilson's work>

Before we examine the existing explanations and remedies for the software engineering deficit in bio-informatics, we make a brief aside: We outline the differences between programming and software engineering in order to prepare for later arguments that lean on these differences.

The ability to program is not the same as the ability to engineer a software solution. Programming is a subset of the discipline of software engineering in the same way that draftsmanship is a subset of the skills required for architecture. This uncontroversial fact is under-appreciated in scientific settings, for reasons about which we can only speculate. In this section, we give an overview of some of the primary tools, techniques and skills of software engineering, and present the results of a survey which seeks to quantify the prevalence of these software engineering elements in bio-informatic settings. Our choice of which tools and techniques to emphasise are based on experience as practioners, and we find ourselves in full agreement with other authors such as Wilson et al. [@wilson2014best] with respect to those choices.

## Description of Software Engineering Values  
The following diagram shows the essential elements of software engineering practice, and illustrates the dependencies between them. We categorize SE elements into the separate layers of Infrastructure, Processes and Practices, each layer building on the one below. 

```{r fig.width=7.5, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ProcessPyramid.png", TRUE)
 grid.raster(img)
```



*Education:* Changes to the existing bio-informatic curricula to teach SE[@umarji2009software]

*Methodology:* [@verma2013lack]

*Engineering Best Practices:* [@wilson2014best] Talk about the best practices that Wilson et al. describe, explain the difference between that education. 

*Participatory Programming:* Is this just another way of saying collaboration? With end users who know how to program? If so, this is effectively saying - do it the normal way.




The core use of software development in bio-informatics is as an instrument of research, taking its place as the "third approach" alongside theory and experiment[@prabhu2011survey] in answering scientific questions. Scripting and high-level programming languages are used to probe data and informally test hypotheses[]. R, Matlab and similar development platforms are used to clean, analyse and present data[]. 

Peripheral to this activity, but in support of it, is the development of basic tools or larger applications, which support projects and goals within single organisations or across the scientific community.

<Reconsider breaking up into these sections. It is not very intuitive and worse, it's creating repetition.>

## Consequences of the Problem for Core Bio-Informatic Activities






## Consequences of the Problem for Peripheral Bio-Informatic Activities



*Under-Performing Tools and Products*: The lack of familiarity with software designs for parallel programming, as well as the structured analysis of performance, naturally affect the tools, utilities and products created as part of peripheral bio-informatics work. Such toolsets and products, when shared and used as part of core research efforts, naturally slow down that core research.

*Under-tested Tools and Products*: In a manner parallel to the previous point on performances, the result of under-tested software created as part of ...




# Existing Explanations and Remedies from the Literature



<Talk about education here> 







# Programming vs Software Engineering


* List the desired features of an engineered solution: Maintainability, Scalability, Modularity, Reproducibility and Testability.


## Description of Survey

## Results of Survey

# Shortcomings of Existing Explanations and Remedies
* Problems with current explanations and their remedies, with reference to the distinction between programming and software engineering. 
* Universities produce computer scientists. Industry (and time) creates software engineers (apprenticeship). There is a time-honoured and thorny argument about whether software engineering is a science or a craft. Emminent figures like EW Dijkstra have offered balanced views on the matter [@dijkstra1982selected] and it is widely recognized that there is an element of apprenticeship in the education of a software engineer. So much so that some authors have investigated ways to simulate this kind of apprenticeship in computer science curricula[@surendran2002simulating]. 
* The lack of software engineering values in bio-informatics is due to the lack of software engineers in bio-informatics. Although Segal & Morris cite the end-user-as-developer as a consequence of the fact that the domain is too complicated for non-biologists, whereas we are more inclined to think that it is a cause rather than a consequence of the lack of software engineering practices. 

* This should not, in our opinion, be addressed by trying to teach bio-informaticians how to become software engineers (in the same way that we don't expect bio-informaticians to learn how to build their own centrifuges and gas chromatograph spectrometers). In fact, we feel this approach is impossible to realize on a scale large enough to solve the problem across the bio-informatics community as a whole. 
* segal&morris: "Other field studies have demonstrated that efforts to impose software engineering techniques on scientists are beset with problems"

* From Hannay: "Scientific software is also often explorative" - suggests misunderstanding of the nature of development, which is also explorative.

* Software Engineers tend to acquire one or more 'verticals'. When they leave university they have no more feeling for the complexity of a payroll package than they have for a polymarase chain reaction.

# Alternative Explanations and Remedies
A better appreciation of the formation and role of a software engineer leads to a different approach for integrating engineering values into a bio-informatic (or generally scientific) setting. While the current emphasis is on cross training scientists to become better programmers, we feel a more rational approach (i.e. more economical, with more likelihood of success) is to cross-train software engineers to support biologists in their use of software (see the grid later for the ways in which software is used in scientific settings). This would be a 'tweak' or specialization for a software engineer from their core competencies, and could be done as part of a career progression for talented engineers (given the undisputed - but not unmatched or unique - complexity of the field).

* A 2010 survery by Nguyen-Huan et al. [@nguyen2010survey] found that most scientists worked "either alone or in a small team of developers" and this too...<maybe better to mention this under reasons for the problem, rather than consequences>

* Cross-training a biologist into software engineering is much less economical as it requires a biologist to take on the entire core competency of software engineering, with the lead-time that this involves.
* Address the problems above requires a clear recognition of diverse roles and needs within a bio-informatic organisation, and commensurate resource planning that should include bio-informatic engineers

## Bio-Informatics Engineering
* Venn Diagrams showing proposed roles.
 
```{r fig.width=6, fig.height=4.5, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/Bio-InformaticProjectRoles.png", TRUE)
 grid.raster(img)
```

* Description of the overlap/interface between the roles


## Differences and Similarities Between Scientific and Commercial Software Projects

* The grid showing four quadrants: Core/Peripheral vs Temporary/Permanent

```{r fig.width=7, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ScientificSoftwareUseScenarios.png", TRUE)
 grid.raster(img)
```
From Morris: "One concern is that scientific prototype code, if successful, segues
into applications that are distributed for wider research use. Later
it may be adopted for production purposes, sometimes even for
safety critical use." (Use this to show that top left quadrant code should be disposed of or rewritten)

Quotable: "We believe that software is just another kind of experimental apparatus [3] and should be built, checked, and used as carefully as any physical apparatus" [@wilson2014best]

* Put another way, the amount of new skills a software engineer needs to acquire to become useful to a biologist is a great deal less than the amount of new skills a biologist needs to learn in order to become useful (to the same extent) to himself.

* We assert there is a level of domain knowledge attainable by software engineers that is _good enough_ to allow her to reliably translate scientific requirements into well-engineered software solutions. By contract, we do not envisage a similar _good enough_ level of software engineering which biologists or bio-informaticians would even _wish_ to attain. 

# Conclusion

# References