---
title: "A Review of Software Engineering Values in Bio-informatic Contexts"
author: "Brendan Lawlor, Paul Walsh"
date: "Saturday, October 27, 2014"
output: pdf_document
bibliography: bibliography.bib
csl: brendan-custom.csl
abstract: In this paper we consider the problem of a lack of software engineering
  skills in bio-informatic contexts and discuss the consequences of this lack. We
  examine existing explanations and remedies to the problem, point out their shortcomings,
  and propose alternatives. Previous analyses of the problem have tended to treat
  the use of software in scientific contexts as categorically different from the general
  application of software engineering in commercial settings. In contrast, we describe it as a specialization of that discipline, and examine 
  how it is practiced. Specifically, we highlight the difference between programming
  and software engineering, list elements of the latter and present the results of
  a survey of bio-informatic practitioners which quantifies the extent to which those
  elements are employed in bio-informatics. In the light of the results we identify
  the role of the bio-informatic engineer - which is unaccounted for in the literature
  - and propose an educational emphasis on cross-training experienced software engineers
---

  
# Outline of the Problem
It has been noted by a number of authors that there is a deficit in software engineering skills within the scientific community in general and the bio-informatic community in particular [@verma2013lack; @baxter2006scientific]. The nature of the problem has been described in detail elsewhere but we outline it here again. Although scientists, and especially cross-disciplinary practitioners, typically possess programming skills and use those skills regularly as part of their work, the way in which software is written in these contexts tends to be ad hoc, unstructured and not in conformity with modern standards of software engineering. This deficit shows up in the software designs employed - undoubtedly rendering programs much less efficient than they might otherwise be[]. It also hinders the reproducibility of published results attained by software, due to an inability of peers to access, build and/or run the underlying source code, or to access the orginal data.

# Consequences of the Problem
In order to look more deeply into the consequences of this engineering gap, we first divide bio-informatics software development activities into two overall types: Core and Peripheral. (This classification will also prove further below.)

The core use of software development in bio-informatics is as an instrument of research, taking its place as the "third approach" alongside theory and experiment[@prabhu2011survey] in answering scientific questions. According to one study, 35% of a scientist's time is spent developing software[@prabhu2011survey]. Scripting and high-level programming languages are used to probe data and informally test hypotheses[]. R, Matlab and similar development platforms are used to clean, analyse and present data[]. 

Peripheral to this activity, but in support of it, is the development of basic tools or larger applications, which support projects and goals within single organisations or across the scientific community.

<Reconsider breaking up into these sections. It is not very intuitive and worse, it's creating repetition.>

## Consequences of the Problem for Core Bio-Informatic Activities
*Inability to Reproduce Findings*: A lack of software engineering infrastructure and techniques means that many publications which process data informatically cannot make that software or data available in a reproducible way for peer review[]. As a consequence, a significant percentage of findings is likely to be reversed or withdrawn from publication. The use of infrastructure such as source code control systems and command-line build tools would improve the situation, but they are either unknown or simply considered unnecessary for small teams by bio-informatic researchers. 

*Unreliability of Findings*: All surveys on scientific software development we have read cite a lack of software testing as being a constant theme of scientfic development. Segal[@segal2007some] points out that the "lack of any disciplined testing procedure" is a characteristic of any development practice where the end user is also the developer. According to a review Morris [@morris2008some] "unit tests often do not exist". Because of the fundamentally important role of such tests in refuting hypotheses about the code, findings based on insufficiently tested software must be considered in turn insufficently tested themselves.

*Limitations in Data Sample Size*: Many scientists run their software on desktops, despite the availability of clusters [] and this is most likely due to a lack of familiarity with software designs for parallel execution of tasks[], or with alternative algorithmic approaches which would give better performance. The contraints that this practice inevitably imposes on sample size or sophistication of data analysis are clear. In order to ensure execution to completion of programs on desktops, albeit in a timeframe of hours and days[@prabhu2011survey], scientists will reduce the number of sample points used, or eliminate steps which might be useful but which have exponential performance profiles.

*Slowing the Discovery Cycle*: As with the previous point, there is another negative consequence for core bio-informatic activity due to poorly-performing software: Given that the process of scientific research is iterative, and a significant proportion of that iteration is taken up with waiting for programs to complete exectution, the entire process of research itself is held back.

In all of the above cases, we can discern a parallel to the argument made by Ioannidis[@ioannidis2005most] with respect to inexpert use of statistics in studies. The danger to progress in bio-informatics is that much research may later be found to be invalid due to inexpert development of software. As  Verma et al. point out, "the end goal of creating accurate and reliable scientific software is no less critical [than with commercial software] since incorrect results would greatly compromise the validity of the discovery"[@verma2013lack]. 

## Consequences of the Problem for Peripheral Bio-Informatic Activities

*Reinventing the wheel*: According to Prabhu et al. [@prabhu2011survey] "a considerable portion of [scientists'] time is spent in many tedious [software development] activities" such as converting data formats or retro-fitting inherited software to work for new conditions. This lost time can be seen as a consequence of the absence of software engineering infrastucture and practices around the research team. Researchers are obliged to repeatedly cobble together solutions for every new direction they take. Naturally the nature of these improvised solutions does not facilitate their reuse - they typically don't exhibit high levels of maintainability or build-reproducibility - and so the problem perpetuates itself.

*Under-Performing Tools and Products*: The lack of familiarity with software designs for parallel programming, as well as the structured analysis of performance, naturally affect the tools, utilities and products created as part of peripheral bio-informatics work. Such toolsets and products, when shared and used as part of core research efforts, naturally slow down that core research.

*Under-tested Tools and Products*: In a manner parallel to the previous point on performances, the result of under-tested software created as part of ...


In summary, the consequence to the field bio-informatics for its lack of software engineering skills is a combination of inefficiency in arriving at new scientific findings and unreliability of those findings when they are reached. By any account, these are significant problems. 

# Existing Explanations and Remedies from the Literature

A number of the authors we have reviewed offer explanations and remedies for the problems described above. Hannay et al. [@hannay2009scientists] identify a general lack of formal education and training and a reliance instead on informal learning from peers. Segal & Morris [@segal2008developing] emphasise the differences between scientific and commercial software development - a theme also covered by the previously mentioned authors. Umarji et al. [@umarji2009software] focus exclusively on the gaps in the education of bio-informatics software developers in software engineering principles. Verma et al. [@verma2013lack] cite a lack of requirements engineering in bio-informatic projects, as well as other factors that create the "unique situation for the field of software engineering" represented by bio-informatics.

<Talk about education here> 

A great deal of space is given to the differences between scientific and commercial development, the implication being that the tools and techniques used in commerical software engineering contexts cannot be applied in scientific settings. Authors have suggested that the two contexts are "fundamentally different" for reasons of subject domain complexity, requirements volitility and budgetary constraints. These differences make it problematic to "impose software engineering techniques on scientists"[@segal2008developing]. 

*Subject Domain Complexity*: Segal & Morris assert that in the case of scientific software development the subject matter is simply too complex for the "average developer". In a similar vein, Hannay suggests that "developers are much less likely to need to be domain experts" in "regular" software development compared to scientific. 

*Requirements Volatility*: According to Segal & Morris, "full up-front requirement specifications are impossible" where scientists are concerned, and that requirements rather "emerge" on an ongoing basis. The suggestion is that this is a distinctive feature of scientific programming, which makes the application of software engineering techniques more difficult.

*Budget and Resources*: Verma et al. cite tighter budget and timetable contraints as a differenciating factor of bio-informatic software development, and therefore as one possible cause of a lack of software engineering best practices. 

*End User (Scientist) as Developer*: A number of authors point out cultural differences between scientists and software engineers as an important issue. Segal & Morris suggest that due to the subject domain complexity already mentioned, developers are likely to be the end-user scientists. But as Verma et al. point out, biologist stakeholders - who are the primary stakeholders in these settings - "may be more inclined to sacrifice program structure to get something that works".


Given the above explanations, the remedies suggested in the literature can be categorized into one of two types. Firstly, many authors make suggestions about how to improve education among scientists and bio-informaticians so as to give an appreciation for software engineering practices. Secondly, some authors describe software development methodologies that would be better suited to bio-informatic or general scientific environments.

*Education:* Changes to the existing bio-informatic curricula to teach SE[@umarji2009software]

*Methodology:* [@verma2013lack]

*Engineering Best Practices:* [@wilson2014best] Talk about the best practices that Wilson et al. describe, explain the difference between that education. 

*Participatory Programming:* Is this just another way of saying collaboration? With end users who know how to program? If so, this is effectively saying - do it the normal way.


# Programming vs Software Engineering

Before we examine the existing explanations and remedies for the software engineering deficit in bio-informatics, we make a brief aside: We outline the differences between programming and software engineering in order to prepare for later arguments that lean on these differences.

The ability to program is not the same as the ability to engineer a software solution. Programming is a subset of the discipline of software engineering in the same way that draftsmanship is a subset of the skills required for architecture. This uncontroversial fact is under-appreciated in scientific settings, for reasons about which we can only speculate. In this section, we give an overview of some of the primary tools, techniques and skills of software engineering, and present the results of a survey which seeks to quantify the prevalence of these software engineering elements in bio-informatic settings. Our choice of which tools and techniques to emphasise are based on experience as practioners, and we find ourselves in full agreement with other authors such as Wilson et al. [@wilson2014best] with respect to those choices.

## Description of Software Engineering Values  
The following diagram shows the essential elements of software engineering practice, and illustrates the dependencies between them. We categorize SE elements into the separate layers of Infrastructure, Processes and Practices, each layer building on the one below. 

```{r fig.width=7.5, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ProcessPyramid.png", TRUE)
 grid.raster(img)
```

* List the desired features of an engineered solution: Maintainability, Scalability, Modularity, Reproducibility and Testability.


## Description of Survey

## Results of Survey

# Shortcomings of Existing Explanations and Remedies
* Problems with current explanations and their remedies, with reference to the distinction between programming and software engineering. 
* Universities produce computer scientists. Industry (and time) creates software engineers (apprenticeship). There is a time-honoured and thorny argument about whether software engineering is a science or a craft. Emminent figures like EW Dijkstra have offered balanced views on the matter [@dijkstra1982selected] and it is widely recognized that there is an element of apprenticeship in the education of a software engineer. So much so that some authors have investigated ways to simulate this kind of apprenticeship in computer science curricula[@surendran2002simulating]. 
* The lack of software engineering values in bio-informatics is due to the lack of software engineers in bio-informatics. Although Segal & Morris cite the end-user-as-developer as a consequence of the fact that the domain is too complicated for non-biologists, whereas we are more inclined to think that it is a cause rather than a consequence of the lack of software engineering practices. 

* This should not, in our opinion, be addressed by trying to teach bio-informaticians how to become software engineers (in the same way that we don't expect bio-informaticians to learn how to build their own centrifuges and gas chromatograph spectrometers). In fact, we feel this approach is impossible to realize on a scale large enough to solve the problem across the bio-informatics community as a whole. 
* segal&morris: "Other field studies have demonstrated that efforts to impose software engineering techniques on scientists are beset with problems"

* From Hannay: "Scientific software is also often explorative" - suggests misunderstanding of the nature of development, which is also explorative.

* Software Engineers tend to acquire one or more 'verticals'. When they leave university they have no more feeling for the complexity of a payroll package than they have for a polymarase chain reaction.

# Alternative Explanations and Remedies
A better appreciation of the formation and role of a software engineer leads to a different approach for integrating engineering values into a bio-informatic (or generally scientific) setting. While the current emphasis is on cross training scientists to become better programmers, we feel a more rational approach (i.e. more economical, with more likelihood of success) is to cross-train software engineers to support biologists in their use of software (see the grid later for the ways in which software is used in scientific settings). This would be a 'tweak' or specialization for a software engineer from their core competencies, and could be done as part of a career progression for talented engineers (given the undisputed - but not unmatched or unique - complexity of the field).

* A 2010 survery by Nguyen-Huan et al. [@nguyen2010survey] found that most scientists worked "either alone or in a small team of developers" and this too...<maybe better to mention this under reasons for the problem, rather than consequences>

* Cross-training a biologist into software engineering is much less economical as it requires a biologist to take on the entire core competency of software engineering, with the lead-time that this involves.
* Address the problems above requires a clear recognition of diverse roles and needs within a bio-informatic organisation, and commensurate resource planning that should include bio-informatic engineers

## Bio-Informatics Engineering
* Venn Diagrams showing proposed roles.
 
```{r fig.width=6, fig.height=4.5, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/Bio-InformaticProjectRoles.png", TRUE)
 grid.raster(img)
```

* Description of the overlap/interface between the roles


## Differences and Similarities Between Scientific and Commercial Software Projects

* The grid showing four quadrants: Core/Peripheral vs Temporary/Permanent

```{r fig.width=7, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ScientificSoftwareUseScenarios.png", TRUE)
 grid.raster(img)
```

Quotable: "We believe that software is just another kind of experimental apparatus [3] and should be built, checked, and used as carefully as any physical apparatus" [@wilson2014best]

* Put another way, the amount of new skills a software engineer needs to acquire to become useful to a biologist is a great deal less than the amount of new skills a biologist needs to learn in order to become useful (to the same extent) to himself.

* We assert there is a level of domain knowledge attainable by software engineers that is _good enough_ to allow her to reliably translate scientific requirements into well-engineered software solutions. By contract, we do not envisage a similar _good enough_ level of software engineering which biologists or bio-informaticians would even _wish_ to attain. 

# Conclusion

# References