---
title: "A Review of Software Engineering Values in Bio-informatic Contexts"
author: "Brendan Lawlor, Paul Walsh"
date: "Saturday, October 27, 2014"
output: pdf_document
bibliography: bibliography.bib
csl: brendan-custom.csl
abstract: In this paper we consider the recognized problem of a lack of software engineering
  skills in bio-informatic contexts and discuss the consequences of this lack. We
  examine existing explanations and remedies to the problem, point out their shortcomings,
  and propose alternatives. Previous analyses of the problem have tended to treat
  the use of software in scientific contexts as categorically different from the general
  application of software engineering in other settings (for example, commercially).
  In contrast, we describe it as a specialization of that discipline, and examine
  how it is practiced. Specifically, we highlight the difference between programming
  and software engineering, list elements of the latter and present the results of
  a survey of bio-informatic practitioners which quantifies the extent to which those
  elements are employed in bio-informatics. In the light of the results we identify
  the role of the bio-informatic engineer - which is unaccounted for in the literature
  - and propose an educational emphasis on cross-training experienced software engineers
---

  
# Outline of the Problem
It has been noted by a number of authors that there is a deficit in software engineering skills within the scientific community in general and the bio-informatic community in particular [@verma2013lack; @baxter2006scientific]. The nature of the problem has been described in detail elsewhere but we outline it here again. Although scientists, and especially cross-disciplinary practitioners, typically possess programming skills and use those skills regularly as part of their work, the way in which software is written in these contexts tends to be ad hoc, unstructured and not in conformity with modern standards of software engineering. This deficit shows up in the software designs employed - undoubtedly rendering programs much less efficient than they might otherwise be[]. It also hinders the reproducibility of published results attained by software, due to an inability of peers to access, build and/or run the underlying source code, or to access the orginal data.

# Consequences of the Problem
In order to look more deeply into the consequences of this engineering gap, we first divide bio-informatics software development activities into two overall types: Core and Peripheral. 

The core use of software development in bio-informatics is as an instrument of research, taking its place as the "third approach" alongside theory and experiment[@prabhu2011survey] in answering scientific questions. According to one study, 35% of a scientist's time is spent developing software[@prabhu2011survey]. Scripting and high-level programming languages are used to probe data and informally test hypotheses[]. R, Matlab and similar development platforms are used to clean, analyse and present data[]. 

Peripheral to this activity, but in support of it, is the development of basic tools or larger applications, which support projects and goals within single organisations or across the scientific community.

## Consequences of the Problem for Core Bio-Informatic Activities
*Inability to Reproduce Findings*: Lack of software engineering infrastructure and techniques means that many publications which process data informatically cannot make that software or data available in a reproducible way for peer review[]. As a consequence, a significant percentage of findings is likely to be reversed or withdrawn from publication. The use of infrastructure such as source code control and build tools would improve the situation, but they are either unknown or simply considered unnecessary for small teams by bio-informatic researchers. 

*Unreliability of Findings*: All surveys on scientific software development we have read cite a lack of software testing as being a constant theme of scientfic development. Segal[@segal2007some] points out that the "lack of any disciplined testing procedure" is a characteristic of any development practice where the end user is also the developer. <More citations on testing>

*Limitations in Data Sample Size*: Many scientists run their software on desktops, despite the availability of clusters [] and this is most likely due to a lack of familiarity with software designs for parallel execution of tasks, or with alternative algorithmic approaches which would give better performance. The contraints that this practice inevitably imposes on sample size or sophistication of data analysis are clear. In order to ensure execution to completion of programs on desktops, albeit in a timeframe of hours and days[@prabhu2011survey], scientists will reduce the number of sample points used, or eliminate steps which might be useful but which have exponential performance profiles.

In all of the above cases, we can discern a parallel to the argument made by Ioannidis[@ioannidis2005most] with respect to inexpert use of statistics in studies. The danger to progress in bio-informatics is that much research may later be found to be invalid due to inexpert development of software.

## Consequences of the Problem for Peripheral Bio-Informatic Activities

*Reinventing the wheel*: According to Prabhu et al. [@prabhu2011survey] "a considerable portion of [scientists'] time is spent in many tedious [software development] activities" such as converting data formats or retro-fitting inherited software to work for new conditions. This lost time can be seen as a consequence of the absence of software engineering infrastucture and practices around the research team. Researchers are obliged to repeatedly cobble together solutions for every new direction they take. Naturally the quality of these improvised solutions does not facilitate their reuse, and the problem perpetuates itself. Two qualities are needed in a software system to allow it to be reused

*Under-Performing Toolsets*: As already stated, the 
Difficulty in productizing, or even openly sharing, promising software solutions. (Scalability) (Reproducibility) (Maintainability)

<Here the discussion can be divided into two sections: inefficient progress due to re-inventing the wheel, and unreliable/buggy products being used in e.g. Healthcare settings.>

<What do these consequences boil down to? Lack of engineering values leads to a reduction in certain important properties of the software written, chiefly Reproducibility, Maintainability, Modularity, Scalability and Testability. But where should we unveil that?>

# Existing Explanations and Remedies from the Literature
## Explanations

* Complexity (special pleading)
* Volatility (special pleading)
* Budget and Resources
* End User (Scientist) as programmer

## Remedies
* Education
* Methodologies

# Programming vs Software Engineering

The ability to program is not the same as the ability to engineer a software solution. Programming is a subset of the discipline of software engineering in the same way that draftsmanship is a subset of the skills required for architecture. This uncontroversial fact is under-appreciated in scientific settings, for reasons about which we can only speculate. In this section, we give an overview of some of the primary tools, techniques and skills of software engineering, and present the results of a survey which seeks to quantify the prevalence of these software engineering elements in bio-informatic settings.

## Description of Software Engineering Values  
With respect to the following diagram:


```{r fig.width=7.5, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ProcessPyramid.png", TRUE)
 grid.raster(img)
```


## Description of Survey

## Results of Survey

# Shortcomings of Existing Explanations and Remedies
* Problems with current explanations and their remedies, with reference to the distinction between programming and software engineering. 
* Universities produce computer scientists. Industry (and time) creates software engineers (apprenticeship). There is a time-honoured and thorny argument about whether software engineering is a science or a craft. Emminent figures like EW Dijkstra have offered balanced views on the matter [@dijkstra1982selected] and it is widely recognized that there is an element of apprenticeship in the education of a software engineer. So much so that some authors have investigated ways to simulate this kind of apprenticeship in computer science curricula[@surendran2002simulating]. 
* The lack of software engineering values in bio-informatics is due to the lack of software engineers in bio-informatics.
* This should not, in our opinion, be addressed by trying to teach bio-informaticians how to become software engineers (in the same way that we don't expect bio-informaticians to learn how to build their own centrifuges and gas chromatograph spectrometers). In fact, we feel this approach is impossible to realize on a scale large enough to solve the problem across the bio-informatics community as a whole. 


# Alternative Explanations and Remedies
A better appreciation of the formation and role of a software engineer leads to a different approach for integrating engineering values into a bio-informatic (or generally scientific) setting. While the current emphasis is on cross training scientists to become better programmers, we feel a more rational approach (i.e. more economical, with more likelihood of success) is to cross-train software engineers to support biologists in their use of software (see the grid later for the ways in which software is used in scientific settings). This would be a 'tweak' or specialization for a software engineer from their core competencies, and could be done as part of a career progression for talented engineers (given the undisputed - but not unmatched or unique - complexity of the field).

* A 2010 survery by Nguyen-Huan et al. [@nguyen2010survey] found that most scientists worked "either alone or in a small team of developers" and this too...<maybe better to mention this under reasons for the problem, rather than consequences>

* Cross-training a biologist into software engineering is much less economical as it requires a biologist to take on the entire core competency of software engineering, with the lead-time that this involves.
* Address the problems above requires a clear recognition of diverse roles and needs within a bio-informatic organisation, and commensurate resource planning that should include bio-informatic engineers

## Bio-Informatics Engineering
* Venn Diagrams showing proposed roles.
 
```{r fig.width=6, fig.height=4.5, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/Bio-InformaticProjectRoles.png", TRUE)
 grid.raster(img)
```

* Description of the overlap/interface between the roles


## Differences and Similarities Between Scientific and Commercial Software Projects

* The grid showing four quadrants: Core/Peripheral vs Temporary/Permanent

```{r fig.width=7, fig.height=7, echo=FALSE, warning=FALSE}
library(png)
library(grid)
img <- readPNG("./images/ScientificSoftwareUseScenarios.png", TRUE)
 grid.raster(img)
```

# Conclusion

# References